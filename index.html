<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CryptoPunk Lookalike Finder</title>
    <!-- Farcaster Mini App Embed Meta Tag -->
    <meta name="fc:miniapp" content='{"version":"1","imageUrl":"https://i.imgur.com/4V0bO3M.png","button":{"title":"Find My Punk","action":{"type":"open","url":"https://your-host.com/app.html"}}}' />
    <!-- Replace imageUrl with a suitable preview image URL. The url in action should be the hosted URL of this file. -->
    <!-- SDK via CDN -->
    <script src="https://unpkg.com/@farcaster/miniapp-sdk@latest/dist/index.js"></script>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; }
        img { max-width: 200px; }
    </style>
</head>
<body>
    <h1>Find Your CryptoPunk Lookalike</h1>
    <div id="avatar-section"></div>
    <div id="progress"></div>
    <div id="result"></div>

    <script>
        async function main() {
            // Instantiate SDK - adjust if the global namespace differs
            const sdk = new window.FarcasterMiniappSdk.MiniAppSDK(); // May need adjustment based on package export; check console if error
            if (!sdk.isInMiniApp()) {
                document.getElementById('progress').innerText = 'Please open this Mini App in a Farcaster client like Warpcast.';
                return;
            }

            const context = sdk.context;
            const pfpUrl = context.user.pfpUrl;
            if (!pfpUrl) {
                document.getElementById('progress').innerText = 'Unable to detect avatar. Please ensure you have one set.';
                return;
            }

            // Display user's avatar
            const avatarSection = document.getElementById('avatar-section');
            avatarSection.innerHTML = '<h2>Your Avatar:</h2><img src="' + pfpUrl + '" alt="Avatar" />';

            // Load avatar image data (resized to 24x24)
            const avatarData = await loadImageData(pfpUrl, true);
            if (!avatarData) {
                document.getElementById('progress').innerText = 'Failed to load avatar image.';
                return;
            }

            // Find the most similar CryptoPunk
            let minMse = Infinity;
            let bestId = -1;
            const progress = document.getElementById('progress');
            const batchSize = 50; // Adjust for performance; higher may be faster but risk browser limits

            for (let start = 0; start < 10000; start += batchSize) {
                const promises = [];
                for (let i = 0; i < batchSize; i++) {
                    const id = start + i;
                    if (id >= 10000) break;
                    promises.push(processPunk(id, avatarData));
                }
                const results = await Promise.all(promises);
                for (const { id, mse } of results) {
                    if (mse < minMse) {
                        minMse = mse;
                        bestId = id;
                    }
                }
                progress.innerText = `Processed ${Math.min(start + batchSize, 10000)} / 10000`;
            }

            progress.innerText = 'Done!';

            // Display result
            const result = document.getElementById('result');
            const punkUrl = getPunkUrl(bestId);
            const openseaUrl = `https://opensea.io/assets/ethereum/0xb47e3cd837ddf8e4c57f05d70ab865de6e193bbb/${bestId}`;
            result.innerHTML = `<h2>Most Similar CryptoPunk: #${bestId}</h2><img src="${punkUrl}" alt="CryptoPunk #${bestId}" /><br><a href="${openseaUrl}" target="_blank">View on OpenSea</a>`;
        }

        function getPunkUrl(id) {
            const padded = id.toString().padStart(4, '0');
            return `https://www.larvalabs.com/public/images/cryptopunks/punk${padded}.png`;
        }

        async function loadImageData(url, useProxy) {
            if (useProxy) {
                url = 'https://images.weserv.nl/?url=' + encodeURIComponent(url);
            }
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.src = url;
            await new Promise((resolve, reject) => {
                img.onload = resolve;
                img.onerror = () => reject(new Error('Image load failed'));
            });
            const canvas = document.createElement('canvas');
            canvas.width = 24;
            canvas.height = 24;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, 24, 24);
            try {
                return ctx.getImageData(0, 0, 24, 24);
            } catch (e) {
                console.error('CORS error:', e);
                return null;
            }
        }

        async function processPunk(id, avatarData) {
            const punkUrl = getPunkUrl(id);
            const punkData = await loadImageData(punkUrl, true);
            if (!punkData) {
                return { id, mse: Infinity };
            }
            const mse = calculateMSE(avatarData, punkData);
            return { id, mse };
        }

        function calculateMSE(data1, data2) {
            let sum = 0;
            const length = data1.data.length;
            for (let i = 0; i < length; i += 4) {
                const dr = data1.data[i] - data2.data[i];
                const dg = data1.data[i + 1] - data2.data[i + 1];
                const db = data1.data[i + 2] - data2.data[i + 2];
                sum += dr * dr + dg * dg + db * db;
            }
            return sum / ((24 * 24) * 3); // Average squared error per channel per pixel
        }

        main().catch(console.error);
    </script>
</body>
</html>
